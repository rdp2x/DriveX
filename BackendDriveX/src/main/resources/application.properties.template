# Application Configuration Template
# Copy this file to application.properties and fill in your actual values
# NEVER commit application.properties to Git!

# Application Configuration
spring.application.name=backend
server.port=8080

# Database Configuration (Supabase PostgreSQL)
# Get these values from your Supabase Dashboard -> Settings -> Database
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://YOUR_PROJECT_REF.supabase.co:5432/postgres}
spring.datasource.username=${DB_USER:postgres}
spring.datasource.password=${DB_PASS:YOUR_DB_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

# Supabase Configuration
# Get these from Supabase Dashboard -> Settings -> API
supabase.url=${SUPABASE_URL:https://YOUR_PROJECT_REF.supabase.co}
supabase.service.key=${SUPABASE_SERVICE_KEY:YOUR_SERVICE_ROLE_KEY}
supabase.bucket.name=${SUPABASE_BUCKET_NAME:DriveX}

# Supabase anon key for making requests to Supabase Auth API
supabase.anon.key=${SUPABASE_ANON_KEY:YOUR_ANON_KEY}

# Supabase JWT secret for validating Supabase tokens
# Get this from Supabase Dashboard -> Settings -> API -> JWT Secret
supabase.jwt.secret=${SUPABASE_JWT_SECRET:YOUR_JWT_SECRET}

# JWT Configuration
# Generate secure random secrets using: openssl rand -base64 64
jwt.secret=${JWT_SECRET:YOUR_JWT_SECRET}
jwt.expires.in=${JWT_EXPIRES_IN:3600}
jwt.refresh.secret=${REFRESH_TOKEN_SECRET:YOUR_REFRESH_TOKEN_SECRET}

# File Upload Configuration
spring.servlet.multipart.max-file-size=${MAX_FILE_SIZE:50MB}
spring.servlet.multipart.max-request-size=${MAX_REQUEST_SIZE:50MB}
# All file types are now allowed by default (except dangerous executables)
# The system now validates based on security rules rather than explicit allowed types
# file.upload.allowed-types is deprecated - validation is now handled in FileService

# CORS Configuration
cors.allowed.origins=${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://127.0.0.1:3000}

# Logging Configuration
logging.level.com.rdp.backend=DEBUG
logging.level.org.springframework.security=DEBUG

# Email Configuration - CONFIGURE THIS TO SEND REAL EMAILS
# 
# QUICK SETUP WITH GMAIL (NO DOMAIN NEEDED):
# 1. Go to https://myaccount.google.com/security
# 2. Enable 2-Factor Authentication
# 3. Go to https://myaccount.google.com/apppasswords
# 4. Create App Password → Select "Mail" → Copy the 16-character password
# 5. Set environment variables OR put them below:
#    export EMAIL_USERNAME=your-email@gmail.com
#    export EMAIL_PASSWORD=your-16-char-app-password
#
# Or set them directly here (replace with your values):
spring.mail.host=${EMAIL_HOST:smtp.gmail.com}
spring.mail.port=${EMAIL_PORT:587}
spring.mail.username=${EMAIL_USERNAME:your-email@gmail.com}
spring.mail.password=${EMAIL_PASSWORD:your-app-password}
spring.mail.properties.mail.smtp.auth=${EMAIL_SMTP_AUTH:true}
spring.mail.properties.mail.smtp.starttls.enable=${EMAIL_STARTTLS:true}
spring.mail.properties.mail.smtp.starttls.required=${EMAIL_STARTTLS:true}
spring.mail.properties.mail.smtp.connectiontimeout=${EMAIL_CONNECTION_TIMEOUT:5000}
spring.mail.properties.mail.smtp.timeout=${EMAIL_TIMEOUT:3000}
spring.mail.properties.mail.smtp.writetimeout=${EMAIL_WRITE_TIMEOUT:5000}

# Alternative: SendGrid (sign up at sendgrid.com for free tier)
# spring.mail.host=${EMAIL_HOST:smtp.sendgrid.net}
# spring.mail.port=${EMAIL_PORT:587}
# spring.mail.username=${EMAIL_USERNAME:apikey}
# spring.mail.password=${EMAIL_PASSWORD:your-sendgrid-api-key}

# Application Configuration
app.frontend.url=${FRONTEND_URL:http://localhost:3000}

# Disable mail health check since SMTP is not configured
management.health.mail.enabled=false
